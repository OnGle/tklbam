'''
This file is essentially a recreation of the original regression test
using the stdlib unittest module.
'''

import unittest
from os.path import abspath, join, isfile
from os import walk, mkdir
import os
from util import testroot, get_path_info, setup, cleanup, assert_stat
import util

#XXX simulations not currently being tested!!!
#XXX uid/gid maps generated by userdb merge not being tested!!!

class TestBase(unittest.TestCase):
    def setUp(self):
        cleanup()
        setup()

    def tearDown(self):
        cleanup()

class TestDirIndex(TestBase):
    def test_creation(self):
        ''' Test `dirindex --create` creates an index file '''

        import dirindex
        # Collect all info on directory using dirindex
        di = dirindex.create('test_tmp/index', ['testdir'])
        self.assertTrue(isfile('test_tmp/index'), 'dirindex index file not created!')

    def test_creation_correct(self):
        ''' Test `dirindex --create` internally represents a directory's contents correctly '''

        import dirindex
        # Collect all info on directory using dirindex
        di = dirindex.create('test_tmp/index', ['testdir'])
        
        # Collect all info on directory manually for reference
        all_paths = {}
        all_paths[abspath('testdir')] = get_path_info('testdir')
        for root, dirs, files in walk('testdir'):
            for name in files+dirs:
                path = abspath(join(root, name))
                all_paths[path] = get_path_info(path)
                
        
        for path in list(di.keys()):
            # ensure all di-paths were also collected manually
            self.assertIn(path, all_paths)

            di_info = di[path]
            test_info = all_paths[path]

            # ensure file info is accurate
            self.assertEqual(di_info.mod, test_info['mode'], 'dirindex path mode incorrect')
            self.assertEqual(di_info.uid, test_info['uid'], 'dirindex path uid incorrect')
            self.assertEqual(di_info.gid, test_info['gid'], 'dirindex path gid incorrect')
            self.assertEqual(di_info.size, test_info['size'], 'dirindex path size incorrect')
            self.assertEqual(di_info.mtime, test_info['mtime'], 'dirindex path mtime incorrect')
            self.assertEqual(di_info.symlink, test_info['symlink'], 'dirindex path symlink incorrect')
            del all_paths[path]
            del di[path]

        self.assertEqual(len(all_paths), 0, 'more paths exist than were found by dirindex')
        self.assertEqual(len(di), 0, 'more paths exist than were found manually') # this is more of a sanity check
        
    def test_fromfile_correct(self):
        ''' Test `dirindex --create`'s index file represents a directory's contents correctly '''

        import dirindex
        # Collect all info on directory using dirindex
        di = dirindex.create('test_tmp/index', ['testdir'])
        di = dirindex.DirIndex('test_tmp/index')
        
        # Collect all info on directory manually for reference
        all_paths = {}
        all_paths[abspath('testdir')] = get_path_info('testdir')
        for root, dirs, files in walk('testdir'):
            for name in files+dirs:
                path = abspath(join(root, name))
                all_paths[path] = get_path_info(path)
                
        
        for path in list(di.keys()):
            # ensure all di-paths were also collected manually
            self.assertIn(path, all_paths)

            di_info = di[path]
            test_info = all_paths[path]

            # ensure file info is accurate
            self.assertEqual(di_info.mod, test_info['mode'], 'dirindex path mode incorrect')
            self.assertEqual(di_info.uid, test_info['uid'], 'dirindex path uid incorrect')
            self.assertEqual(di_info.gid, test_info['gid'], 'dirindex path gid incorrect')
            self.assertEqual(di_info.size, test_info['size'], 'dirindex path size incorrect')
            self.assertEqual(di_info.mtime, test_info['mtime'], 'dirindex path mtime incorrect')
            self.assertEqual(di_info.symlink, test_info['symlink'], 'dirindex path symlink incorrect')
            del all_paths[path]
            del di[path]

        self.assertEqual(len(all_paths), 0, 'more paths exist than were found by dirindex')
        self.assertEqual(len(di), 0, 'more paths exist than were found manually') # this is more of a sanity check
            
    def test_creation_with_limitation_correct(self):
        ''' Test `dirindex --create` with limitations internally represents a directory's contents correctly '''

        import dirindex
        # Collect all info on directory using dirindex
        di = dirindex.create('test_tmp/index', ['--', './testdir/', '-testdir/subdir/', 'testdir/subdir/subsubdir'])
        
        # Collect all info on directory manually for reference
        all_paths = {}
        all_paths[abspath('testdir')] = get_path_info('testdir')
        for root, dirs, files in walk('testdir'):
            for name in files+dirs:
                path = abspath(join(root, name))
                if ('testdir/subdir' in path and not 'testdir/subdir/subsubdir' in path):
                    continue

                all_paths[path] = get_path_info(path)
                
        
        for path in list(di.keys()):
            # ensure all di-paths were also collected manually
            self.assertIn(path, all_paths)

            di_info = di[path]
            test_info = all_paths[path]

            # ensure file info is accurate
            self.assertEqual(di_info.mod, test_info['mode'], 'dirindex path mode incorrect')
            self.assertEqual(di_info.uid, test_info['uid'], 'dirindex path uid incorrect')
            self.assertEqual(di_info.gid, test_info['gid'], 'dirindex path gid incorrect')
            self.assertEqual(di_info.size, test_info['size'], 'dirindex path size incorrect')
            self.assertEqual(di_info.mtime, test_info['mtime'], 'dirindex path mtime incorrect')
            self.assertEqual(di_info.symlink, test_info['symlink'], 'dirindex path symlink incorrect')
            del all_paths[path]
            del di[path]

        self.assertEqual(len(all_paths), 0, 'more paths exist than were found by dirindex')
        self.assertEqual(len(di), 0, 'more paths exist than were found manually') # this is more of a sanity check

    def test_dirindex_delta(self):
        ''' Test `dirindex --create` delta '''

        import dirindex
        import changes
        # Collect all info on directory using dirindex
        before_di = dirindex.create('test_tmp/before_index', ['testdir'])

        util.mv('testdir/file', 'testdir/file-renamed')
        util.rm('testdir/link')
        util.ln_s('testdir/file-renamed', 'testdir/link')
        util.mv('testdir/emptydir', 'testdir/emptydir-renamed')
        util.appendToFile('testdir/subdir/file2', 'changed\n')
        util.chgrp('testdir/subdir/file2', 666)
        util.writeToFile('testdir/subdir/subsubdir/file4', 'foo')
        util.chown('testdir/subdir/subsubdir/file4', 666)
        util.rm('testdir/subdir/subsubdir/file3')
        util.mkdir('testdir/new')
        util.touch('testdir/new/empty')

        util.chown('testdir/chown', 666)
        util.chgrp('testdir/chgrp', 666)
        util.chmod('testdir/chmod', 0o000)
        
        util.chown('testdir/subdir', 666, 666)
        util.chmod('testdir/subdir/subsubdir', 0o750)

        changes = changes.whatchanged('test_tmp/before_index', ['testdir'])

        change_map = { change.path: change for change in changes }

        def check_equality(change, op, uid=None, gid=None, mode=None):
            self.assertEqual(change.OP, op)
            if op in ('o', 's'):
                self.assertEqual(change.uid, uid)
                self.assertEqual(change.gid, gid)
            if op == 's':
                self.assertEqual(change.mode, mode)
            

        # files moved/deleted
        check_equality(change_map[abspath('testdir/emptydir')], 'd')
        check_equality(change_map[abspath('testdir/file')], 'd')
        check_equality(change_map[abspath('testdir/subdir/subsubdir/file3')], 'd')

        # files new/changed
        check_equality(change_map[abspath('testdir/file-renamed')], 'o', 999, 999)
        check_equality(change_map[abspath('testdir/link')], 'o', 0, 0)
        check_equality(change_map[abspath('testdir/new/empty')], 'o', 0, 0)
        check_equality(change_map[abspath('testdir/subdir/file2')], 'o', 999, 666)
        check_equality(change_map[abspath('testdir/subdir/subsubdir/file4')], 'o', 666, 0)
        
        # files with only stat changes
        check_equality(change_map[abspath('testdir/chgrp')], 's', 999, 666, 0o100644)
        check_equality(change_map[abspath('testdir/chmod')], 's', 999, 999, 0o100000)
        check_equality(change_map[abspath('testdir/chown')], 's', 666, 999, 0o100644)
        check_equality(change_map[abspath('testdir/emptydir-renamed')], 's', 999, 999, 0o40755)
        check_equality(change_map[abspath('testdir/new')], 's', 0, 0, 0o40755)
        check_equality(change_map[abspath('testdir/subdir')], 's', 666, 666, 0o40755)
        check_equality(change_map[abspath('testdir/subdir/subsubdir')], 's', 999, 999, 0o40750)

    def test_fixstat(self):
        ''' Test `fixstat` basic usage '''

        import dirindex
        import changes

        # create dirindex
        before_di = dirindex.create('test_tmp/before_index', ['testdir'])

        # make some changes
        util.chmod('testdir/subdir', 0o700)
        util.chown('testdir/chown', 0)
        util.chgrp('testdir/chown', 0)
        util.chmod('testdir/chmod', 0o741)
        util.chown('testdir/subdir/subsubdir', 0, 0)
        util.rm('testdir/subdir/subsubdir/file3')

        # save a change delta
        delta = changes.whatchanged('test_tmp/before_index', ['testdir'])
        delta.tofile('test_tmp/delta')

        # make some more changes
        util.chmod('testdir/subdir', 0o077)
        util.chown('testdir/chown', 666)
        util.chmod('testdir/chmod', 0o770)
        util.chown('testdir/subdir/subsubdir', 999, 999)
        util.touch('testdir/subdir/subsubdir/file3')

        # generate stat fixes to rollback
        changes_list = changes.Changes.fromfile('test_tmp/delta', ['testdir'])

        import os

        # check and ensure all actions are correct
        actions = list(changes_list.statfixes())
        self.assertEqual(len(actions), 4)

        for action in actions[:]:
            if action.args[0] == abspath('testdir/subdir'):
                self.assertEqual(action.func, os.chmod)
                self.assertEqual(action.args[1], 0o700)
                action()
                actions.remove(action)
            elif action.args[0] == abspath('testdir/chown'):
                self.assertEqual(action.func, os.lchown)
                self.assertEqual(action.args[1], 0) # uid
                self.assertEqual(action.args[2], 0) # gid
                action()
                actions.remove(action)
            elif action.args[0] == abspath('testdir/chmod'):
                self.assertEqual(action.func, os.chmod)
                self.assertEqual(action.args[1], 0o741)
                action()
                actions.remove(action)
            elif action.args[0] == abspath('testdir/subdir/subsubdir'):
                self.assertEqual(action.func, os.lchown)
                self.assertEqual(action.args[1], 0) # uid
                self.assertEqual(action.args[2], 0) # gid
                action()
                actions.remove(action)

        # ensure all actions *were* taken
        assert_stat(self.assertEqual, 'testdir/subdir', mode=0o700)
        assert_stat(self.assertEqual, 'testdir/chown', uid=0, gid=0)
        assert_stat(self.assertEqual, 'testdir/chmod', mode=0o741)
        assert_stat(self.assertEqual, 'testdir/subdir/subsubdir', uid=0, gid=0)
    
        # ensure there are no left-over actions
        self.assertEqual(len(actions), 0)

    def test_fixstat_with_limitation(self):
        ''' Test `fixstat` with limitation '''

        import dirindex
        import changes

        # create dirindex
        before_di = dirindex.create('test_tmp/before_index', ['testdir'])

        # make some changes
        util.chmod('testdir/subdir', 0o700)
        util.chown('testdir/chown', 0)
        util.chgrp('testdir/chown', 0)
        util.chmod('testdir/chmod', 0o741)
        util.chown('testdir/subdir/subsubdir', 0, 0)
        util.rm('testdir/subdir/subsubdir/file3')

        # save a change delta
        delta = changes.whatchanged('test_tmp/before_index', ['testdir'])
        delta.tofile('test_tmp/delta')

        # make some more changes
        util.chmod('testdir/subdir', 0o077)
        util.chown('testdir/chown', 666)
        util.chmod('testdir/chmod', 0o770)
        util.chown('testdir/subdir/subsubdir', 999, 999)
        util.touch('testdir/subdir/subsubdir/file3')

        # generate stat fixes to rollback
        changes_list = changes.Changes.fromfile('test_tmp/delta', ['testdir/subdir'])

        import os

        # check and ensure all actions are correct
        actions = list(changes_list.statfixes())
        self.assertEqual(len(actions), 2)

        for action in actions[:]:
            if action.args[0] == abspath('testdir/subdir'):
                self.assertEqual(action.func, os.chmod)
                self.assertEqual(action.args[1], 0o700)
                action()
                actions.remove(action)
            elif action.args[0] == abspath('testdir/chown'):
                self.assertEqual(action.func, os.lchown)
                self.assertEqual(action.args[1], 0) # uid
                self.assertEqual(action.args[2], 0) # gid
                action()
                actions.remove(action)
            elif action.args[0] == abspath('testdir/chmod'):
                self.assertEqual(action.func, os.chmod)
                self.assertEqual(action.args[1], 0o741)
                action()
                actions.remove(action)
            elif action.args[0] == abspath('testdir/subdir/subsubdir'):
                self.assertEqual(action.func, os.lchown)
                self.assertEqual(action.args[1], 0) # uid
                self.assertEqual(action.args[2], 0) # gid
                action()
                actions.remove(action)

        # ensure all actions *were* taken
        assert_stat(self.assertEqual, 'testdir/subdir', mode=0o700) # rolled back
        assert_stat(self.assertEqual, 'testdir/chown', uid=666, gid=0) # not rolled back
        assert_stat(self.assertEqual, 'testdir/chmod', mode=0o770) # not rolled back
        assert_stat(self.assertEqual, 'testdir/subdir/subsubdir', uid=0, gid=0) # rolled back
    
        # ensure there are no left-over actions
        self.assertEqual(len(actions), 0)

    def test_fixstat_with_exclusion(self):
        ''' Test `fixstat` with exclusion '''

        import dirindex
        import changes

        # create dirindex
        before_di = dirindex.create('test_tmp/before_index', ['testdir'])

        # make some changes
        util.chmod('testdir/subdir', 0o700)
        util.chown('testdir/chown', 0)
        util.chgrp('testdir/chown', 0)
        util.chmod('testdir/chmod', 0o741)
        util.chown('testdir/subdir/subsubdir', 0, 0)
        util.rm('testdir/subdir/subsubdir/file3')

        # save a change delta
        delta = changes.whatchanged('test_tmp/before_index', ['testdir'])
        delta.tofile('test_tmp/delta')

        # make some more changes
        util.chmod('testdir/subdir', 0o077)
        util.chown('testdir/chown', 666)
        util.chmod('testdir/chmod', 0o770)
        util.chown('testdir/subdir/subsubdir', 999, 999)
        util.touch('testdir/subdir/subsubdir/file3')

        # generate stat fixes to rollback
        changes_list = changes.Changes.fromfile('test_tmp/delta', ['--', 'testdir', '-testdir/subdir'])

        import os

        # check and ensure all actions are correct
        actions = list(changes_list.statfixes())
        self.assertEqual(len(actions), 2)

        for action in actions[:]:
            if action.args[0] == abspath('testdir/chown'):
                self.assertEqual(action.func, os.lchown)
                self.assertEqual(action.args[1], 0) # uid
                self.assertEqual(action.args[2], 0) # gid
                action()
                actions.remove(action)
            elif action.args[0] == abspath('testdir/chmod'):
                self.assertEqual(action.func, os.chmod)
                self.assertEqual(action.args[1], 0o741)
                action()
                actions.remove(action)

        # ensure all actions *were* taken
        assert_stat(self.assertEqual, 'testdir/subdir', mode=0o077) # not rolled back
        assert_stat(self.assertEqual, 'testdir/chown', uid=0, gid=0) # rolled back
        assert_stat(self.assertEqual, 'testdir/chmod', mode=0o741) # rolled back
        assert_stat(self.assertEqual, 'testdir/subdir/subsubdir', uid=999, gid=999) # not rolled back
    
        # ensure there are no left-over actions
        self.assertEqual(len(actions), 0)

    def test_fixstat_with_uid_gid_mapping(self):
        ''' Test `fixstat` with uid and gid mapping '''

        import dirindex
        import changes

        # create dirindex
        before_di = dirindex.create('test_tmp/before_index', ['testdir'])

        # make some changes
        util.chown('testdir/chown', 111)
        util.chgrp('testdir/chown', 666)
        util.chown('testdir/subdir/subsubdir', 222, 777)

        # save a change delta
        delta = changes.whatchanged('test_tmp/before_index', ['testdir'])
        delta.tofile('test_tmp/delta')

        # make some more changes
        util.chown('testdir/chown', 333)
        util.chown('testdir/subdir/subsubdir', 999, 999)

        # generate stat fixes to rollback
        changes_list = changes.Changes.fromfile('test_tmp/delta', ['testdir'])

        import os

        uid_map = {666:777, 111:222}
        gid_map = {666:777, 111:222}

        # check and ensure all actions are correct
        actions = list(changes_list.statfixes(uid_map, gid_map))
        self.assertEqual(len(actions), 2)

        for action in actions[:]:
            if action.args[0] == abspath('testdir/chown'):
                self.assertEqual(action.func, os.lchown)
                self.assertEqual(action.args[1], 222) # uid
                self.assertEqual(action.args[2], 777) # gid
                action()
                actions.remove(action)
            elif action.args[0] == abspath('testdir/subdir/subsubdir'):
                self.assertEqual(action.func, os.lchown)
                self.assertEqual(action.args[1], 222) # uid
                self.assertEqual(action.args[2], 777) # gid
                action()
                actions.remove(action)

        # ensure all actions *were* taken
        assert_stat(self.assertEqual, 'testdir/chown', uid=222, gid=777)
        assert_stat(self.assertEqual, 'testdir/subdir/subsubdir', uid=222, gid=777)
    
        # ensure there are no left-over actions
        self.assertEqual(len(actions), 0)

    def test_fixstat_with_uid_gid_mapping_rerun(self):
        ''' Test `fixstat` with uid and gid mapping (rerun, nothing to do) '''

        import dirindex
        import changes

        # create dirindex
        before_di = dirindex.create('test_tmp/before_index', ['testdir'])

        # make some changes
        util.chown('testdir/chown', 111)
        util.chgrp('testdir/chown', 666)
        util.chown('testdir/subdir/subsubdir', 222, 777)

        # save a change delta
        delta = changes.whatchanged('test_tmp/before_index', ['testdir'])
        delta.tofile('test_tmp/delta')

        # make some more changes
        util.chown('testdir/chown', 333)
        util.chown('testdir/subdir/subsubdir', 999, 999)

        # generate stat fixes to rollback
        changes_list = changes.Changes.fromfile('test_tmp/delta', ['testdir'])

        import os

        uid_map = {666:777, 111:222}
        gid_map = {666:777, 111:222}

        # check and ensure all actions are correct
        actions = list(changes_list.statfixes(uid_map, gid_map))
        self.assertEqual(len(actions), 2)

        for action in actions[:]:
            action()
            actions.remove(action)

        # ensure all actions *were* taken
        assert_stat(self.assertEqual, 'testdir/chown', uid=222, gid=777)
        assert_stat(self.assertEqual, 'testdir/subdir/subsubdir', uid=222, gid=777)
    
        # ensure there are no left-over actions
        self.assertEqual(len(actions), 0)

        # rerun stat fixes
        changes_list = changes.Changes.fromfile('test_tmp/delta', ['testdir'])
        
        actions = list(changes_list.statfixes(uid_map, gid_map))
        self.assertEqual(len(actions), 0)

    def test_dirindex_comparison_with_limitation(self):
        ''' Test directory comparison with limitation '''
        
        import dirindex
        import changes
         
        # Collect all info on directory using dirindex
        before_di = dirindex.create('test_tmp/before_index', ['testdir'])
        
        util.mv('testdir/file', 'testdir/file-renamed')
        util.rm('testdir/link')
        util.ln_s('testdir/file-renamed', 'testdir/link')
        util.mv('testdir/emptydir', 'testdir/emptydir-renamed')
        util.appendToFile('testdir/subdir/file2', 'changed\n')
        util.chgrp('testdir/subdir/file2', 666)
        util.writeToFile('testdir/subdir/subsubdir/file4', 'foo')
        util.chown('testdir/subdir/subsubdir/file4', 666)
        util.rm('testdir/subdir/subsubdir/file3')
        util.mkdir('testdir/new')
        util.touch('testdir/new/empty')

        util.chown('testdir/chown', 666)
        util.chgrp('testdir/chgrp', 666)
        util.chmod('testdir/chmod', 0o000)
        
        util.chown('testdir/subdir', 666, 666)
        util.chmod('testdir/subdir/subsubdir', 0o750)

        changes = changes.whatchanged('test_tmp/before_index', ['--', 'testdir/subdir/', '-testdir/subdir/subsubdir'])

        change_map = { change.path: change for change in changes }

        def check_equality(change, op, uid=None, gid=None, mode=None):
            self.assertEqual(change.OP, op)
            if op in ('o', 's'):
                self.assertEqual(change.uid, uid)
                self.assertEqual(change.gid, gid)
            if op == 's':
                self.assertEqual(change.mode, mode)
            

        # files moved/deleted
        self.assertNotIn(abspath('testdir/emptydir'), change_map)
        self.assertNotIn(abspath('testdir/file'), change_map)
        self.assertNotIn(abspath('testdir/subdir/subsubdir/file3'), change_map)

        # files new/changed
        self.assertNotIn(abspath('testdir/file-renamed'), change_map)
        self.assertNotIn(abspath('testdir/link'), change_map)
        self.assertNotIn(abspath('testdir/new/empty'), change_map)
        check_equality(change_map[abspath('testdir/subdir/file2')], 'o', 999, 666)
        self.assertNotIn(abspath('testdir/subdir/subsubdir/file4'), change_map)
        
        # files with only stat changes
        self.assertNotIn(abspath('testdir/chgrp'), change_map)
        self.assertNotIn(abspath('testdir/chmod'), change_map)
        self.assertNotIn(abspath('testdir/chown'), change_map)
        self.assertNotIn(abspath('testdir/emptydir-renamed'), change_map)
        self.assertNotIn(abspath('testdir/new'), change_map)
        self.assertNotIn(abspath('testdir/subdir/subsubdir'), change_map)
        check_equality(change_map[abspath('testdir/subdir')], 's', 666, 666, 0o40755)
        
    def test_dirindex_comparison_with_inverted_limitation(self):
        ''' Test directory comparison with inverted limitation '''
        
        import dirindex
        import changes
         
        # Collect all info on directory using dirindex
        before_di = dirindex.create('test_tmp/before_index', ['testdir'])
        
        util.mv('testdir/file', 'testdir/file-renamed')
        util.rm('testdir/link')
        util.ln_s('testdir/file-renamed', 'testdir/link')
        util.mv('testdir/emptydir', 'testdir/emptydir-renamed')
        util.appendToFile('testdir/subdir/file2', 'changed\n')
        util.chgrp('testdir/subdir/file2', 666)
        util.writeToFile('testdir/subdir/subsubdir/file4', 'foo')
        util.chown('testdir/subdir/subsubdir/file4', 666)
        util.rm('testdir/subdir/subsubdir/file3')
        util.mkdir('testdir/new')
        util.touch('testdir/new/empty')

        util.chown('testdir/chown', 666)
        util.chgrp('testdir/chgrp', 666)
        util.chmod('testdir/chmod', 0o000)
        
        util.chown('testdir/subdir', 666, 666)
        util.chmod('testdir/subdir/subsubdir', 0o750)

        changes = changes.whatchanged('test_tmp/before_index', ['--', 'testdir/', '-testdir/subdir',
                'testdir/subdir/subsubdir'])

        change_map = { change.path: change for change in changes }

        def check_equality(change, op, uid=None, gid=None, mode=None):
            self.assertEqual(change.OP, op)
            if op in ('o', 's'):
                self.assertEqual(change.uid, uid)
                self.assertEqual(change.gid, gid)
            if op == 's':
                self.assertEqual(change.mode, mode)
            
        # files moved/deleted
        check_equality(change_map[abspath('testdir/emptydir')], 'd')
        check_equality(change_map[abspath('testdir/file')], 'd')
        check_equality(change_map[abspath('testdir/subdir/subsubdir/file3')], 'd')

        # files new/changed
        check_equality(change_map[abspath('testdir/file-renamed')], 'o', 999, 999)
        check_equality(change_map[abspath('testdir/link')], 'o', 0, 0)
        check_equality(change_map[abspath('testdir/new/empty')], 'o', 0, 0)
        self.assertNotIn(abspath('testdir/subdir/file2'), change_map)
        check_equality(change_map[abspath('testdir/subdir/subsubdir/file4')], 'o', 666, 0)
        
        # files with only stat changes
        check_equality(change_map[abspath('testdir/chgrp')], 's', 999, 666, 0o100644)
        check_equality(change_map[abspath('testdir/chmod')], 's', 999, 999, 0o100000)
        check_equality(change_map[abspath('testdir/chown')], 's', 666, 999, 0o100644)
        check_equality(change_map[abspath('testdir/emptydir-renamed')], 's', 999, 999, 0o40755)
        check_equality(change_map[abspath('testdir/new')], 's', 0, 0, 0o40755)
        self.assertNotIn(abspath('testdir/subdir'), change_map)
        check_equality(change_map[abspath('testdir/subdir/subsubdir')], 's', 999, 999, 0o40750)

    def test_delete(self):
        ''' Test deletion '''
        
        import dirindex
        import changes

        # create dirindex
        before_di = dirindex.create('test_tmp/before_index', ['testdir'])

        # make some changes
        util.chmod('testdir/subdir', 0o700)
        util.chown('testdir/chown', 0)
        util.chgrp('testdir/chown', 0)
        util.rm('testdir/subdir/subsubdir/file3')
        util.rm('testdir/file')

        # save a change delta
        delta = changes.whatchanged('test_tmp/before_index', ['testdir'])
        delta.tofile('test_tmp/delta')

        # make some more changes
        util.chmod('testdir/subdir', 0o077)
        util.chown('testdir/chown', 666)
        util.touch('testdir/subdir/subsubdir/file3')
        util.touch('testdir/file')

        # generate stat fixes to rollback
        changes_list = changes.Changes.fromfile('test_tmp/delta', ['testdir'])

        import os

        # check and ensure all actions are correct
        actions = list(changes_list.deleted())
        self.assertEqual(len(actions), 2)

        for action in actions[:]:
            action()
            actions.remove(action)

        # ensure all actions *were* taken
        self.assertFalse(isfile(abspath('testdir/subdir/subsubdir/file3')))
        self.assertFalse(isfile(abspath('testdir/file')))
    
        # ensure there are no left-over actions
        self.assertEqual(len(actions), 0)

    def test_delete_with_limitation(self):
        ''' Test deletion with limitation '''
        
        import dirindex
        import changes

        # create dirindex
        before_di = dirindex.create('test_tmp/before_index', ['testdir'])

        # make some changes
        util.chmod('testdir/subdir', 0o700)
        util.chown('testdir/chown', 0)
        util.chgrp('testdir/chown', 0)
        util.rm('testdir/subdir/subsubdir/file3')
        util.rm('testdir/file')

        # save a change delta
        delta = changes.whatchanged('test_tmp/before_index', ['testdir'])
        delta.tofile('test_tmp/delta')

        # make some more changes
        util.chmod('testdir/subdir', 0o077)
        util.chown('testdir/chown', 666)
        util.touch('testdir/subdir/subsubdir/file3')
        util.touch('testdir/file')

        # generate stat fixes to rollback
        changes_list = changes.Changes.fromfile('test_tmp/delta', ['testdir/subdir'])

        import os

        # check and ensure all actions are correct
        actions = list(changes_list.deleted())
        self.assertEqual(len(actions), 1)

        for action in actions[:]:
            action()
            actions.remove(action)

        # ensure all actions *were* taken
        self.assertFalse(isfile(abspath('testdir/subdir/subsubdir/file3')))
        self.assertTrue(isfile(abspath('testdir/file')))
    
        # ensure there are no left-over actions
        self.assertEqual(len(actions), 0)

    def test_delete_rerun(self):
        ''' Test deletion rerun (nothing to do) '''
        
        import dirindex
        import changes

        # create dirindex
        before_di = dirindex.create('test_tmp/before_index', ['testdir'])

        # make some changes
        util.chmod('testdir/subdir', 0o700)
        util.chown('testdir/chown', 0)
        util.chgrp('testdir/chown', 0)
        util.rm('testdir/subdir/subsubdir/file3')
        util.rm('testdir/file')

        # save a change delta
        delta = changes.whatchanged('test_tmp/before_index', ['testdir'])
        delta.tofile('test_tmp/delta')

        # make some more changes
        util.chmod('testdir/subdir', 0o077)
        util.chown('testdir/chown', 666)
        util.touch('testdir/subdir/subsubdir/file3')
        util.touch('testdir/file')

        # generate stat fixes to rollback
        changes_list = changes.Changes.fromfile('test_tmp/delta', ['testdir'])

        import os

        # check and ensure all actions are correct
        actions = list(changes_list.deleted())
        self.assertEqual(len(actions), 2)

        for action in actions[:]:
            action()
            actions.remove(action)

        # ensure all actions *were* taken
        self.assertFalse(isfile(abspath('testdir/subdir/subsubdir/file3')))
        self.assertFalse(isfile(abspath('testdir/file')))

        # ensure there are no left-over actions
        self.assertEqual(len(actions), 0)

        changes_list = changes.Changes.fromfile('test_tmp/delta', ['testdir'])
        actions = list(changes_list.deleted())
        self.assertEqual(len(actions), 0)

class TestUserDB(TestBase):
    def test_userdb_merge_group(self):
        ''' Test userdb group merge '''

        import userdb

        with open('test_reference/old-group', 'r') as fob:
            old_group = fob.read()
        with open('test_reference/new-group', 'r') as fob:
            new_group = fob.read()

        g1 = userdb.EtcGroup(old_group)
        g2 = userdb.EtcGroup(new_group)
        g3, gid_map = userdb.EtcGroup.merge(g1, g2)

        all_group_names = g3.keys()
        g1_names = g1.keys()
        g2_names = g2.keys()

        # ensure no groups were lost during merge
        for name in all_group_names:
            self.assertTrue(name in g1_names or name in g2_names)
        for name in g1_names:
            self.assertIn(name, all_group_names)
        for name in g2_names:
            self.assertIn(name, all_group_names)

        # ensure no duplicate gids exist
        all_gids = set()

        for name in all_group_names:
            all_gids.add(g3[name][2]) # 2 = gid field

        self.assertEqual(len(all_gids), len(all_group_names))

    def test_userdb_merge_passwd(self):
        ''' Test userdb passwd merge '''

        import userdb

        with open('test_reference/old-passwd', 'r') as fob:
            old_passwd = fob.read()
        with open('test_reference/new-passwd', 'r') as fob:
            new_passwd = fob.read()

        u1 = userdb.EtcPasswd(old_passwd)
        u2 = userdb.EtcPasswd(new_passwd)
        u3, uid_map = userdb.EtcPasswd.merge(u1, u2)

        all_user_names = u3.keys()
        u1_names = u1.keys()
        u2_names = u2.keys()

        # ensure no user were lost during merge
        for name in all_user_names:
            self.assertTrue(name in u1_names or name in u2_names)
        for name in u1_names:
            self.assertIn(name, all_user_names)
        for name in u2_names:
            self.assertIn(name, all_user_names)

        # ensure no duplicate uids exist
        all_uids = set()

        for name in all_user_names:
            all_uids.add(u3[name][2]) # 2 = uid field

        self.assertEqual(len(all_uids), len(all_user_names))

    def test_userdb_merge(self):
        ''' Test userdb full merge '''
        # again this test is more of a sanity check

        import userdb

        with open('test_reference/old-group', 'r') as fob:
            old_group = fob.read()
        with open('test_reference/new-group', 'r') as fob:
            new_group = fob.read()
        with open('test_reference/old-passwd', 'r') as fob:
            old_passwd = fob.read()
        with open('test_reference/new-passwd', 'r') as fob:
            new_passwd = fob.read()

        merged_passwd, merged_group, uidmap, gidmap = userdb.merge(old_passwd, old_group, new_passwd, new_group)
        
        u1 = userdb.EtcPasswd(old_passwd)
        u2 = userdb.EtcPasswd(new_passwd)

        g1 = userdb.EtcGroup(old_group)
        g2 = userdb.EtcGroup(new_group)

        # ensure no users or groups were lost during merge (highly unlikely if previous userdb tests have passed)
        all_user_names = merged_passwd.keys()
        for name in all_user_names:
            self.assertTrue(name in u1 or name in u2)
        for name in [*u1.keys(), *u2.keys()]:
            self.assertIn(name, all_user_names)

        all_group_names = merged_group.keys()
        for name in all_group_names:
            self.assertTrue(name in g1 or name in g2)
        for name in [*g1.keys(), *g2.keys()]:
            self.assertIn(name, all_group_names)

        # ensure no duplicate uid/gids exist
        all_uids = set()
        for name in all_user_names:
            all_uids.add(merged_passwd[name][2]) # 2 - uid
        self.assertEqual(len(all_uids), len(all_user_names))

        all_gids = set()
        for name in all_group_names:
            all_gids.add(merged_group[name][2]) # 2 - gid
        self.assertEqual(len(all_gids), len(all_group_names))

class TestPkgman(TestBase):
    def test_newpkgs(self):
        ''' Test newpkgs (this test is ultimately a test of sets, is it even necessary?) '''
        
        from pkgman import Packages 

        pkgs1 = Packages.fromfile('test_reference/base-packages')
        pkgs2 = Packages.fromfile('test_reference/old-packages')

        new_pkgs = pkgs2 - pkgs1

        self.assertEqual(set(new_pkgs), (set(pkgs2)-set(pkgs1)))
        
    def test_newpkgs_install(self):
        ''' Test newpkgs install internals '''

        from pkgman import Installer, Packages

        packages = [
            # doesn't exist, should be skipped
            b'foofoobar',
            b'fobarbar',

            # already installed, silently ignore
            b'dpkg',
            b'base-files',

            # not installed (probably) 
            b'aspell-fa',
            b'aspell-hy'
        ]

        installer = Installer(packages)

        self.assertEqual(set(installer.skipping), {b'foofoobar', b'fobarbar'})
        self.assertEqual(set(installer.installable), {b'aspell-fa', b'aspell-hy'})
        self.assertEqual(installer.command, [b'apt-get', b'install', b'--assume-yes', b'aspell-fa', b'aspell-hy'],
            "incorrect newpkgs install apt-command (note this test can fail if you have aspell-fa and/or aspell-hy installed")

class TestMysql(TestBase):
    def test_mysql2fs2mysql_blind(self):
        ''' Test mysql2fs blindly (convert a mysql dump to tkl file format and back again) '''
        
        import mysql
        from io import StringIO

        if not util.is_installed('mysql-server') or not util.is_installed('mysql-client'):
            self.skipTest('mysql related tests require \'mysql-server\' and \'mysql-client\' to be installed!')
        if not os.environ.get('ENABLE_TKLBAM_MYSQL_TESTS', 'FALSE').lower() == 'true':
            self.skipTest(
                'mysql related tests require "ENABLE_TKLBAM_MYSQL_TESTS" env-var to be set to ' +
                'be set to "True" to ensure you understand the potentially destructive effects of ' +
                'said tests')

        import mysql_util

        mysql_util.ensure_mysql_running()
        # drop a possible left-over drupal6 db
        mysql_util.mysql_execute('drop database drupal6;')

        # turn mysql dump to tklbam fs format
        mkdir('test_tmp/mysqlfs')
        with open('test_reference/mysql-dump-test', 'r') as fob:
            mysql.mysql2fs(fob, 'test_tmp/mysqlfs')
        
        # load tklbam mysqlfs format back into sql
        with open('test_tmp/mysqlfs-to-dump', 'w') as fob:
            mysql.fs2mysql(fob, 'test_tmp/mysqlfs')

        # execute sql in mysql
        mysql_util.mysql_execute_file('test_tmp/mysqlfs-to-dump')

        # dump mysql again
        mysql_util.mysqldump('test_tmp/last-dump')

        with open('test_tmp/last-dump', 'r') as fob1:
            with open('test_tmp/mysqlfs-to-dump', 'r') as fob2:
                with open('test_reference/mysql-dump-test', 'r') as fob3:
                    for line1, line2, line3 in zip(fob1, fob2, fob3):
                        self.assertTrue(line1 == line2 == line3)

if __name__ == '__main__':
    unittest.main()
